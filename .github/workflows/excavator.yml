on:
  schedule:
    # Run every hour to check for new versions
    - cron: '0 * * * *'
  workflow_dispatch:

name: Excavator

jobs:
  excavate:
    name: Check for Updates
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for new versions
        id: excavator
        uses: ScoopInstaller/GithubActions@main
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SKIP_UPDATED: '1'

      - name: Update citron nightly
        shell: pwsh
        run: |
          Write-Host "Checking citron for updates..."
          $ProgressPreference = 'SilentlyContinue'
          .\bin\update-manifest.ps1 -ManifestPath bucket\citron.json -Update
          if ($LASTEXITCODE -eq 0) {
            $changed = git diff --name-only bucket/citron.json
            if ($changed) {
              Write-Host "Citron updated - changes detected"
              git add bucket\citron.json
              git config user.name "github-actions[bot]"
              git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
              git commit -m "feat(citron): update to latest nightly"
              git push origin HEAD:master
              Write-Host "Citron update committed and pushed"
            } else {
              Write-Host "Citron is already up to date"
            }
          } else {
            Write-Host "Citron update failed"
          }

      - name: Capture excavator output
        shell: pwsh
        run: |
          Write-Host "Excavator step outcome: ${{ steps.excavator.outcome }}" -ForegroundColor Cyan
          Write-Host "Excavator step outputs: ${{ toJson(steps.excavator.outputs) }}" -ForegroundColor Gray

      - name: Capture excavator errors
        id: capture-errors
        shell: pwsh
        run: |
          # Check excavator outcome and look for manifest errors
          $excavatorResult = "${{ steps.excavator.outcome }}"
          Write-Host "=== Excavator Results ===" -ForegroundColor Cyan
          Write-Host "Excavator outcome: $excavatorResult" -ForegroundColor Gray

          $brokenManifests = @()
          $hasErrors = $false

          # Always attempt to identify error manifests, regardless of overall outcome
          Write-Host "Checking for manifest errors..." -ForegroundColor Yellow

          # Strategy 1: Check git diff for partially modified manifests
          # (excavator may have started updating but errored out)
          $modifiedManifests = @(git diff --name-only HEAD | Where-Object { $_ -match '^bucket/.*\.json$' })

          # Strategy 2: Check git status for staged/unstaged changes
          if ($modifiedManifests.Count -eq 0) {
            $stagedFiles = @(git diff --cached --name-only | Where-Object { $_ -match '^bucket/.*\.json$' })
            $unstagedFiles = @(git diff --name-only | Where-Object { $_ -match '^bucket/.*\.json$' })
            $modifiedManifests = @($stagedFiles + $unstagedFiles | Select-Object -Unique)
          }

          # Strategy 3: Look at recent commits to see what excavator was trying to update
          if ($modifiedManifests.Count -eq 0) {
            try {
              $lastCommit = git log -1 --pretty=format:%H
              $modifiedManifests = @(git diff --name-only $lastCommit~1..$lastCommit | Where-Object { $_ -match '^bucket/.*\.json$' })
            } catch {
              Write-Host "Could not get recent commits: $_" -ForegroundColor Gray
            }
          }

          if ($modifiedManifests.Count -gt 0) {
            Write-Host "Found $($modifiedManifests.Count) modified manifest(s)" -ForegroundColor Yellow
            $brokenManifests = $modifiedManifests | ForEach-Object { (Split-Path -LeafBase $_) }
            $brokenManifests | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
            $hasErrors = $true
          } else {
            Write-Host "No modified manifests found in git" -ForegroundColor Gray
          }

          # Strategy 4: Parse excavator output/logs for error messages
          # Check if any manifests had errors even if overall step succeeded
          $excavatorOutput = "${{ steps.excavator.outputs.result }}"
          if ($excavatorOutput) {
            Write-Host "Checking excavator output for errors..." -ForegroundColor Yellow
            # Look for patterns indicating errors in the output
            $errorPatterns = @(
              ':\s+The remote server returned an error',
              ':\s+.*?(404|not found|error|failed)',
              'Error.*?(URL|checkver)'
            )
            foreach ($pattern in $errorPatterns) {
              $matches = [regex]::Matches($excavatorOutput, $pattern, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [System.Text.RegularExpressions.RegexOptions]::Multiline)
              if ($matches.Count -gt 0) {
                Write-Host "Found error patterns in excavator output" -ForegroundColor Yellow
                $hasErrors = $true
                break
              }
            }
          }

          # Strategy 5: Check if excavator actually failed
          if ($excavatorResult -eq 'failure') {
            Write-Host "Excavator step failed - likely a manifest error" -ForegroundColor Yellow
            if ($brokenManifests.Count -eq 0) {
              Write-Host "No specific manifests identified from git, will check all base manifests" -ForegroundColor Yellow
              $brokenManifests = @(Get-ChildItem -Path "bucket" -Filter "*.json" -File | Where-Object { $_.Name -notmatch '(-nightly|-dev)' } | Select-Object -ExpandProperty BaseName)
              Write-Host "Total manifests to check: $($brokenManifests.Count)" -ForegroundColor Gray
            }
            $hasErrors = $true
          }

          if ($hasErrors) {
            # If no specific manifests identified, check all base manifests
            if ($brokenManifests.Count -eq 0) {
              Write-Host "No specific manifests identified, will check all base manifests in auto-fix" -ForegroundColor Yellow
              $brokenManifests = @(Get-ChildItem -Path "bucket" -Filter "*.json" -File | Where-Object { $_.Name -notmatch '(-nightly|-dev)' } | Select-Object -ExpandProperty BaseName)
              Write-Host "Total manifests to check: $($brokenManifests.Count)" -ForegroundColor Gray
            }

            # Save broken manifests list to file for next step
            $brokenManifests | ConvertTo-Json | Out-File -FilePath "broken-manifests.json" -Encoding UTF8
            Write-Host "Saved $($brokenManifests.Count) manifest(s) to broken-manifests.json" -ForegroundColor Green

            Write-Host "Error manifests identified:" -ForegroundColor Red
            $brokenManifests | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }

            # Output as GitHub Actions output
            "broken-manifests=$($brokenManifests -join ',')" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
            "has-errors=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append

            Write-Host "Manifest errors detected, will report and attempt auto-fix" -ForegroundColor Red
          } else {
            Write-Host "[OK] No manifest errors detected" -ForegroundColor Green
            "has-errors=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
          }

      - name: Upload broken manifests list
        if: steps.capture-errors.outputs.has-errors == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: broken-manifests
          path: broken-manifests.json
          retention-days: 1
