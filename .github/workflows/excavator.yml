on:
  schedule:
    # Run every hour to check for new versions
    - cron: '0 * * * *'
  workflow_dispatch:

name: Excavator

jobs:
  excavate:
    name: Check for Updates
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@main
        with:
          fetch-depth: 0

      - name: Check for new versions
        id: excavator
        uses: ScoopInstaller/GithubActions@main
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SKIP_UPDATED: '1'

      - name: Capture excavator errors
        id: capture-errors
        shell: pwsh
        run: |
          # Check excavator outcome and look for manifest errors
          $excavatorResult = "${{ steps.excavator.outcome }}"
          Write-Host "=== Excavator Results ===" -ForegroundColor Cyan
          Write-Host "Excavator outcome: $excavatorResult" -ForegroundColor Gray

          $brokenManifests = @()
          $hasErrors = $false

          # Always attempt to identify error manifests, regardless of overall outcome
          Write-Host "Checking for manifest errors..." -ForegroundColor Yellow

          # Strategy 1: Check git diff for partially modified manifests
          # (excavator may have started updating but errored out)
          $modifiedManifests = @(git diff --name-only HEAD | Where-Object { $_ -match '^bucket/.*\.json$' })

          # Strategy 2: Check git status for staged/unstaged changes
          if ($modifiedManifests.Count -eq 0) {
            $stagedFiles = @(git diff --cached --name-only | Where-Object { $_ -match '^bucket/.*\.json$' })
            $unstagedFiles = @(git diff --name-only | Where-Object { $_ -match '^bucket/.*\.json$' })
            $modifiedManifests = @($stagedFiles + $unstagedFiles | Select-Object -Unique)
          }

          # Strategy 3: Look at recent commits to see what excavator was trying to update
          if ($modifiedManifests.Count -eq 0) {
            try {
              $lastCommit = git log -1 --pretty=format:%H
              $modifiedManifests = @(git diff --name-only $lastCommit~1..$lastCommit | Where-Object { $_ -match '^bucket/.*\.json$' })
            } catch {
              Write-Host "Could not get recent commits: $_" -ForegroundColor Gray
            }
          }

          if ($modifiedManifests.Count -gt 0) {
            Write-Host "Found $($modifiedManifests.Count) modified manifest(s)" -ForegroundColor Yellow
            $brokenManifests = $modifiedManifests | ForEach-Object { (Split-Path -LeafBase $_) }
            $brokenManifests | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
            $hasErrors = $true
          } else {
            Write-Host "No modified manifests found in git" -ForegroundColor Gray
          }

          # Strategy 4: Parse excavator output/logs for error messages
          # Check if any manifests had errors even if overall step succeeded
          $excavatorOutput = "${{ steps.excavator.outputs.result }}"
          if ($excavatorOutput) {
            Write-Host "Checking excavator output for errors..." -ForegroundColor Yellow
            # Look for patterns indicating errors in the output
            $errorPatterns = @(
              ':\s+The remote server returned an error',
              ':\s+.*?(404|not found|error|failed)',
              'Error.*?(URL|checkver)'
            )
            foreach ($pattern in $errorPatterns) {
              $matches = [regex]::Matches($excavatorOutput, $pattern, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase -bor [System.Text.RegularExpressions.RegexOptions]::Multiline)
              if ($matches.Count -gt 0) {
                Write-Host "Found error patterns in excavator output" -ForegroundColor Yellow
                $hasErrors = $true
                break
              }
            }
          }

          if ($hasErrors) {
            # If no specific manifests identified, check all base manifests
            if ($brokenManifests.Count -eq 0) {
              Write-Host "No specific manifests identified, will check all base manifests in auto-fix" -ForegroundColor Yellow
              $brokenManifests = @(Get-ChildItem -Path "bucket" -Filter "*.json" -File | Where-Object { $_.Name -notmatch '(-nightly|-dev)' } | Select-Object -ExpandProperty BaseName)
              Write-Host "Total manifests to check: $($brokenManifests.Count)" -ForegroundColor Gray
            }

            # Save broken manifests list to file for next step
            $brokenManifests | ConvertTo-Json | Out-File -FilePath "broken-manifests.json" -Encoding UTF8
            Write-Host "Saved $($brokenManifests.Count) manifest(s) to broken-manifests.json" -ForegroundColor Green

            Write-Host "Error manifests identified:" -ForegroundColor Red
            $brokenManifests | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }

            # Output as GitHub Actions output
            "broken-manifests=$($brokenManifests -join ',')" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
            "has-errors=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append

            Write-Host "Manifest errors detected, will report and attempt auto-fix" -ForegroundColor Red
          } else {
            Write-Host "[OK] No manifest errors detected" -ForegroundColor Green
            "has-errors=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
          }

      - name: Parse excavator logs for errors
        if: steps.capture-errors.outputs.has-errors == 'true'
        id: parse-logs
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');

            // Get the current run ID
            const runId = context.runId;

            // First, list jobs for this workflow run to get the job ID
            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            // Find the job with name 'excavate'
            const excavateJob = jobsResponse.data.jobs.find(job => job.name === 'excavate');
            if (!excavateJob) {
              console.log('Could not find excavate job in workflow run');
              core.setOutput('log-errors', '');
              return;
            }

            const jobId = excavateJob.id;
            console.log(`Found excavate job ID: ${jobId}`);

            // Fetch the logs for this job
            const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              job_id: jobId
            });

            // Parse the logs to find error messages
            // Pattern: "appname: error message" or "appname: The remote server returned an error: (404) Not Found"
            const logsText = Buffer.from(logs.data).toString('utf-8');
            const errorPatterns = [
              /^(\w+):\s+The remote server returned an error:\s*\([0-9]+\).*$/m,
              /^(\w+):\s+.*?(?:404|not found|error|failed).*$/mi,
              /Error.*?(\w+).*?(?:URL|checkver).*$/mi
            ];

            const foundErrors = new Set();

            // Search for each pattern
            errorPatterns.forEach(pattern => {
              const matches = logsText.matchAll(pattern);
              for (const match of matches) {
                if (match[1]) {
                  foundErrors.add(match[1].toLowerCase());
                }
              }
            });

            if (foundErrors.size > 0) {
              const errorList = Array.from(foundErrors).join(',');
              console.log(`Found ${foundErrors.size} errors in logs: ${errorList}`);
              core.setOutput('log-errors', errorList);
            } else {
              console.log('No specific errors found in logs');
              core.setOutput('log-errors', '');
            }

      - name: Upload broken manifests list
        if: steps.capture-errors.outputs.has-errors == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: broken-manifests
          path: broken-manifests.json
          retention-days: 1
