on:
  schedule:
    # Run twice daily to fix broken manifests
    - cron: '0 0,12 * * *'
  workflow_dispatch:
  # Trigger on push to bucket if manifests change
  push:
    paths:
      - 'bucket/*.json'
  # Trigger when excavator completes (especially on failure)
  workflow_run:
    workflows: [Excavator]
    types: [completed]

name: Auto-Fix Manifests

jobs:
  autofix:
    name: Fix Broken Manifests
    runs-on: windows-latest
    # Run on all triggers
    steps:
      - uses: actions/checkout@main

      - name: Log trigger reason
        shell: pwsh
        run: |
          $triggerEvent = "${{ github.event_name }}"
          Write-Host "=== Auto-Fix Workflow Triggered ===" -ForegroundColor Cyan
          Write-Host "Trigger: $triggerEvent" -ForegroundColor Gray

          if ($triggerEvent -eq "workflow_run") {
            $status = "${{ github.event.workflow_run.conclusion }}"
            Write-Host "Excavator status: $status" -ForegroundColor $(if ($status -eq "failure") { "Red" } else { "Yellow" })
          }

      - name: Download broken manifests list
        id: download-errors
        if: github.event_name == 'workflow_run'
        continue-on-error: true
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id,
            });

            const matchArtifact = artifacts.data.artifacts.find(artifact =>
              artifact.name === 'broken-manifests'
            );

            if (!matchArtifact) {
              console.log('No broken-manifests artifact found');
              return;
            }

            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: matchArtifact.id,
              archive_format: 'zip',
            });

            fs.writeFileSync('${{ github.workspace }}/broken-manifests.zip', Buffer.from(download.data));
            console.log('Downloaded broken-manifests artifact');

      - name: Extract and parse broken manifests
        id: parse-errors
        shell: pwsh
        run: |
          $brokenManifests = @()

          # Check if we have the broken manifests artifact
          if (Test-Path "broken-manifests.zip") {
            Write-Host "Extracting broken manifests..." -ForegroundColor Cyan
            Expand-Archive -Path "broken-manifests.zip" -DestinationPath "." -Force

            if (Test-Path "broken-manifests.json") {
              $content = Get-Content -Path "broken-manifests.json" -Raw
              try {
                $brokenManifests = $content | ConvertFrom-Json
              } catch {
                Write-Host "Failed to parse broken-manifests.json, will process all" -ForegroundColor Yellow
              }
            }
          }

          if ($brokenManifests.Count -gt 0) {
            Write-Host "Found $($brokenManifests.Count) broken manifest(s) to fix:" -ForegroundColor Yellow
            $brokenManifests | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
            "manifests-to-fix=$($brokenManifests -join ',')" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
          } else {
            Write-Host "No specific manifests identified, will process all" -ForegroundColor Gray
            "manifests-to-fix=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding UTF8 -Append
          }

      - name: Install Scoop
        shell: pwsh
        run: |
          # Install Scoop package manager
          Write-Host "Installing Scoop..." -ForegroundColor Cyan

          # Set Scoop environment variables
          $env:SCOOP = "$env:USERPROFILE\scoop"
          $env:SCOOP_HOME = "$env:SCOOP\apps\scoop\current"

          # Download and install Scoop
          iex (New-Object Net.WebClient).DownloadString('https://get.scoop.sh')

          # Set environment variables for subsequent steps
          "SCOOP=$env:SCOOP" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "SCOOP_HOME=$env:SCOOP_HOME" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Scoop installed successfully" -ForegroundColor Green

      - name: Setup Scoop environment
        shell: pwsh
        run: |
          # Ensure Scoop environment is set up
          if ($env:SCOOP -eq $null) {
            $env:SCOOP = "$env:USERPROFILE\scoop"
          }
          if ($env:SCOOP_HOME -eq $null) {
            $env:SCOOP_HOME = "$env:SCOOP\apps\scoop\current"
          }

          # Ensure scoop is in PATH if not already
          if ($env:PATH -notlike "*scoop*") {
            $env:PATH = "$env:SCOOP\shims;$env:PATH"
          }

          # Set environment variables for subsequent steps
          "SCOOP=$env:SCOOP" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "SCOOP_HOME=$env:SCOOP_HOME" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Auto-fix broken manifests
        shell: pwsh
        run: |
          $bucketPath = "${{ github.workspace }}/bucket"
          $scriptsPath = "${{ github.workspace }}/bin"
          $manifestsToFix = "${{ steps.parse-errors.outputs.manifests-to-fix }}"

          Write-Host "Starting auto-fix process..." -ForegroundColor Cyan
          Write-Host "SCOOP_HOME: $env:SCOOP_HOME" -ForegroundColor Gray
          Write-Host "SCOOP: $env:SCOOP" -ForegroundColor Gray

          # Determine which manifests to process
          if ($manifestsToFix) {
            Write-Host "Processing specific manifests from excavator errors..." -ForegroundColor Yellow
            $appNames = $manifestsToFix -split ','
            $manifests = Get-ChildItem -Path $bucketPath -Filter "*.json" -File |
              Where-Object { $appNames -contains $_.BaseName -and $_.Name -notmatch '(-nightly|-dev)' }
          } else {
            Write-Host "Processing all manifests..." -ForegroundColor Gray
            $manifests = Get-ChildItem -Path $bucketPath -Filter "*.json" -File |
              Where-Object { $_.Name -notmatch '(-nightly|-dev)' }
          }

          Write-Host "Found $($manifests.Count) manifests to check"

          $fixedCount = 0
          foreach ($manifest in $manifests) {
            Write-Host "`n[$(Get-Date -Format 'HH:mm:ss')] Processing $($manifest.BaseName)..."

            # Run auto-fix script
            $result = & "$scriptsPath\autofix-manifest.ps1" -ManifestPath $manifest.FullName -BucketPath $bucketPath

            $exitCode = $LASTEXITCODE
            if ($exitCode -eq 0) {
              Write-Host "[OK] Fixed: $($manifest.BaseName)" -ForegroundColor Green
              $fixedCount++
            }
          }

          Write-Host "`n=== Auto-fix process complete ===" -ForegroundColor Cyan
          Write-Host "Fixed: $fixedCount manifest(s)" -ForegroundColor Cyan

      - name: Commit and push changes
        shell: pwsh
        run: |
          git config user.name "Scoop Auto-Updater"
          git config user.email "auto-updater@scoop.sh"
          git add bucket/

          $status = git status --porcelain
          if ($status) {
            Write-Host "Found changes to commit:" -ForegroundColor Green
            Write-Host $status
            git commit -m "chore: Auto-fix broken manifests"
            git push
            Write-Host "âœ“ Changes pushed" -ForegroundColor Green
          } else {
            Write-Host "No manifest changes to commit" -ForegroundColor Gray
          }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
